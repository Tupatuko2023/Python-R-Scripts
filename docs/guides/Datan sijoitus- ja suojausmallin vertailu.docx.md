# Datan sijoitus- ja suojausmallin vertailu

## Päätösmatriisi

| Kriteeri | Vaihtoehto A: Raakadata GPG-salattuna repossa | Vaihtoehto B: Raakadata ei repossa (vain viitteet/metadata) |
| :---- | :---- | :---- |
| **Tietosuoja & compliance** | **3/5.** Data on kyllä vahvasti salattu (vain ADMIN:lla avain), mikä pienentää tietoturvariskiä, mutta itse **raakadatan tallentaminen repositorioon rikkoo minimointiperiaatetta** – dataa säilytetään enemmän kuin on pakollista[\[1\]](https://www.fortinet.com/resources/cyberglossary/gdpr#:~:text=information%20to%20the%20data%20collector,is%20accountable%20and%20responsible%20for). Lisäksi organisaation lupaehtojen kannalta pelkkä salaus ei välttämättä riitä, jos ehtoina on ettei dataa saa säilyttää tietyissä paikoissa. Parempi kuin selväkielinen tallennus, mutta silti ylimääräinen kopio olemassa. | **5/5.** **Ei säilytetä lainkaan henkilötietoja repossa**, vain tarvittavat metatiedot. Tämä täyttää tietosuojan minimointivaatimuksen erinomaisesti[\[1\]](https://www.fortinet.com/resources/cyberglossary/gdpr#:~:text=information%20to%20the%20data%20collector,is%20accountable%20and%20responsible%20for) – koodi- ja dokumentaatiorepo ei sisällä lainkaan suojattavaa dataa. Vuotoriski on minimaalinen, ja malli on linjassa lupaehtojen kanssa, koska raakadata pysyy vain sallituissa sijainneissa. |
| **Käytettävyys workflow’issa** | **2/5.** Automatisoidut ajot (CI/CD, Quarto-renderöinnit) eivät pysty avaamaan dataa ilman avainta, joten **monet workflow’t pysähtyvät**. Käytännössä vain admin voi lokaalisti purkaa datan ja ajaa analyysit, mikä on pullonkaula. Muille kehittäjille tai agenteille prosessi on lukossa. | **4/5.** Automaatiot voidaan suunnitella ohittamaan herkän datan tarpeen tai käyttämään esim. julkisia placeholder-tietoja testeissä. Koska data on repossa vain viitteenä, CI-putket voidaan ajaa (esim. Quarto-renderöinti voi käyttää valmiiksi agregoituja tuloksia tai ohittaa dataosat). Paikallisessa kehityksessä käyttäjän pitää erikseen hankkia data turvallista reittiä, mutta kun se on tehty, workflow’t toimivat normaalisti. Työvirrat ovat siis joustavampia kuin A:ssa, vaikkakin edellyttävät yhtä manuaalista vaihetta (datan haku). |
| **Reproducibility & audit trail** | **5/5.** Kaikki analyysiin tarvittava on tallessa versiohallinnassa: salattu raakadata on versionhallinnan piirissä, joten jokainen muutos dataan näkyy git-historiassa. Tämä takaa tarkan audit trailin ja toistettavuuden (edellyttäen, että avain on saatavilla). Esimerkiksi commit-historiasta näkee, milloin data (salattuna tiedostona) muuttui, ja ADMIN voi halutessaan palauttaa tietyn version ja purkaa sen. | **4/5.** Repossa on vain viittaukset dataan (esim. manifestit, checksummat, versiokoodi). Toistettavuus on mahdollinen, **mutta edellyttää huolellista dokumentointia ja versionumeroiden/häshien hallintaa**. Manifestit on pidettävä ajan tasalla aina kun data vaihtuu. Oikein toteutettuna audit trail on vahva (manifestista nähdään mitä dataa kukin analyysiversio käytti), mutta se ei ole automaattista gitin puolesta kuten A:ssa. |
| **Onboarding & portability** | **3/5.** Uuden kehittäjän on kloonattuaan repon pyydettävä salausavain adminilta ja asennettava GPG asetukset, jotta saa datan auki. Itse data tulee repossa mukana (salattuna), joten erillistä latausta ei tarvita, mutta **avaimen jakelu ja purkuvaihe** on manuaalinen ja vaatii opastusta. Monella koneella (tai CI-ympäristössä) toimiminen on hankalaa, koska avain ei saa vuotaa – käytännössä vain tietyissä koneissa data avataan. | **4/5.** Uuden käyttäjän on kloonattuaan repon hankittava raakadata erillisestä sijainnista (esim. organisaation suojattu tiedostojärjestelmä) ja sijoitettava se ohjeiden mukaiseen polkuun. Tämä on ylimääräinen askel, mutta hyvin dokumentoituna suoraviivainen. **Projekti on muuten kevyt kloonata** (ei massiivista datatiedostoa), ja polut voidaan määritellä konfiguraatiossa, mikä helpottaa siirrettävyyttä (esim. data voidaan mountata konttiin erikseen). Onboardingissa tärkeää on hyvät ohjeet datan saamiseen. |
| **Operatiivinen turvallisuus** | **3/5.** Salauksen ansiosta data on turvassa repossa, vaikka joku siihen käsiksi saisikin – ilman avainta sisältö pysyy suojattuna[\[2\]](https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control#:~:text=You%27re%20best%20bet%20is%20to,is%20looking%20over%20your%20shoulder). **Avainhallinta kuitenkin on kriittinen heikko lenkki:** jos avain olisi koskaan CI-ympäristössä, vuotoriski olisi suuri, joten sitä ei voida automaatiossa käyttää. Vain ADMIN:lla oleva avain pienentää hyökkäyspintaa, mutta toisaalta yhden henkilön varassa oleminen on riski (avaimen häviäminen, henkilön poissaolo). Lisäksi on aina mahdollista inhimillisestä erehdyksestä, että avain tai vahingossa dekryptattu data vuotaa. | **5/5.** Koska repoon **ei tallenneta mitään salaamatonta eikä salaista** (vain metadataa), on hyvin vähän mahdollisuuksia vuotaa tietoja versionhallinnan tai CI/CD-putken kautta. .gitignore suojaa vahingossa tapahtuvilta commiteilta[\[3\]](https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control#:~:text=I%20also%20find%20it%20helpful,accidentally%20check%20in%20anything%20sensitive), eikä CI:ssä tarvitse käsitellä avaimia tai salausoperaatioita lainkaan. Avainhallinta rajoittuu siihen ympäristöön, missä dataa säilytetään (esim. tietokanta tai tiedostovarasto, johon on erilliset käyttöoikeudet). Operatiivisesti malli on turvallinen: CI/CD-putkessa ei ole riskiä tulostaa lokiin tai artefakteihin mitään arkaluontoista. |
| **Agenttiystävällisyys** (RAG/indexointi) | **4/5.** Koodiaineistoa lukeva tekoälyagentti ei pysty lukemaan raakadataa, koska se on salattu mössöä. Tämä on hyvä – agentti pysyy “pimeänä” suojatun datan sisällöstä. Pieni haitta on, että agentti saattaa nähdä salatun tiedoston olemassaolon, mikä voi aiheuttaa turhia kysymyksiä, tai agentin pitää osata sivuuttaa tietyt polut. Kokonaisuudessaan aineisto on kuitenkin melko turvallista agentin käsitellä, kunhan se **ei saa avainta**. | **5/5.** Agentti voi huoletta indeksoida ja käyttää repositorion materiaalia, koska siellä on vain sallitut tiedot: dokumentaatiota, metadataa ja mahdollisesti tilastollisia yhteenvetoja. **Agentilla ei ole pääsyä raakadataan** lainkaan, joten RAG (Retrieval Augmented Generation) \-haut pysyvät turvallisissa rajoissa. Tämä malli on selkeärajainen: agentti tietää, että se lukee vain avointa materiaalia, eikä edes yritä päästä käsiksi ulkopuoliseen raakadataan. |
| **Ylläpidettävyys** (pitkän aikavälin huolto) | **2/5.** Salausmalli vaatii jatkuvaa huomiota: adminin on päivitettävä salattu tiedosto aina, kun raakadata muuttuu, ja varmistettava ettei salauksen kanssa tule mokia. **Git-historian hallinta vaikeutuu**, jos salattu tiedosto on suuri ja muuttuu usein (repo pullistuu historiassa). Myös työvirhetilanteissa debuggaus on hankalampaa – esim. jos CI epäonnistuu datan puutteeseen, pitää muistaa miksi (avainta ei saatavilla). Lisäksi riski inhimillisille virheille on olemassa: väärillä gitattribute-asetuksilla voi vahingossa commitata salaamattoman version[\[4\]](https://news.ycombinator.com/item?id=7508734#:~:text=After%204%20months%20of%20usage%2C,crypt), tai repo voi mennä epäkoherenttiin tilaan salauksen vuoksi[\[5\]](https://news.ycombinator.com/item?id=7508734#:~:text=The%20second%20issue%20is%20that,crypt%20versions). Pitkässä juoksussa ratkaisu on monimutkainen ylläpitää ja altis virheille. | **4/5.** Koodi- ja dokumentaatiorepo pysyy **kevyenä ja suoraviivaisena ylläpitää**, kun siellä ei pyöri suuria binääritiedostoja. Datan versioinnin hallinta tapahtuu hallitusti manifestien avulla ja itse data on erillisessä säilytyspaikassa (esim. sisäisessä tietovarastossa). Tämä tuo hieman lisää prosessia (pitää muistaa päivittää manifesti), mutta toisaalta erottaa selkeästi koodin ja datan elinkaaret. **Repoon voidaan tehdä muutoksia vapaammin** pelkäämättä, että vahingossa sotketaan raakadataa. Myös esim. avoimen lähdekoodin julkaisun voi tehdä helpommin, kun data ei ole mukana – riittää poistella viiteaineisto tai korvata se. Ylläpidettävyys on hyvä, kun dokumentaatio ohjaa datan päivityksissä. Lisäksi ratkaisu skaalautuu suuriin datamääriin, koska päärepo pysyy pienenä[\[6\]](https://dataengineeracademy.com/blog/data-version-control-a-comprehensive-guide/#:~:text=Solution%3A%20One%20of%20DVC%E2%80%99s%20strengths,storage%20utilization%20and%20rapid%20synchronization) (data säilötään muualla). |

## Suositus

Suosituksemme on **Vaihtoehto B**, eli **raakadata pidetään kokonaan pois varsinaisesta Git-reposta** ja repositorioon jätetään vain viitteellinen tieto (metadata, manifesti, dokumentaatio). Tämä malli osoittautuu paremmaksi erityisesti tietosuojan, operatiivisen turvallisuuden ja ylläpidettävyyden kannalta. Vaihtoehto B eliminoi riskin, että arkaluontoinen data vuotaa versionhallinnan tai CI-putken kautta, ja noudattaa tietosuojaperiaatteita (minimointi: ei tallenneta enempää dataa kuin on välttämätöntä)[\[1\]](https://www.fortinet.com/resources/cyberglossary/gdpr#:~:text=information%20to%20the%20data%20collector,is%20accountable%20and%20responsible%20for). Samalla se parantaa workflow’n joustavuutta – koodin testaus, dokumentin generointi ja agenttihaut voidaan toteuttaa ilman että törmätään salausesteisiin. Vaikka Option A (salattu data repossa) suojasi sisältöä kryptografisesti, sen käytännön haitat (automaation estyminen, avainhallinnan vaikeus, ylläpitokuorma) ovat merkittäviä, eikä ole olemassa turvallista tapaa avata dataa CI-ympäristössä ilman avainvuodon riskiä – tämän myöntää myös käytännön kokemus: jos suurin osa repositorion sisällöstä on salattua dataa, ratkaisu ei ole tarkoituksenmukainen[\[7\]](https://news.ycombinator.com/item?id=7508734#:~:text=As%20for%20security%2C%20,your%20suggestion%20of%20a%20command). Siksi Option B on kokonaisuutena kestävämpi ja suositeltava ratkaisu.

## Toteutusohjeet (viiteimplementaatio)

Seuraavassa on käytännön ohjeistus valitun mallin (vaihtoehto B) toteuttamiseksi repossa:

* **Kansiorakenne:** Jätä ennalleen projektin data/\-hakemistorakenne metatiedostoille, mutta **älä tallenna raakadataa repoon**. Esimerkiksi data/external/\-kansioon voi jättää vain tyhjän placeholder-tiedoston tai README:n. Varsinainen data säilytetään repositorion ulkopuolella, esimerkiksi polussa jonka käyttäjä määrittelee ympäristömuuttujana (esim. DATA\_PATH=/secure/location/filename.csv). Koodi voi ladata dataa tuon polun kautta. Näin projektin hakemistorakenne peilaa datan paikkaa kuitenkaan sisältämättä sitä suoraan.

* **.gitignore\-säädöt:** Lisää .gitignore\-tiedostoon säännöt, jotka estävät vahingossa tapahtuvat datatiedostojen commitoinnit. Esimerkiksi: data/external/\*\* (jättää huomiotta kaikki mahdolliset alihakemistot ja tiedostot data/external\-polun alla). Tämä varmistaa, että jos joku vahingossa kopioi raakadatatiedoston repoon, se ei päädy versionhallintaan[\[3\]](https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control#:~:text=I%20also%20find%20it%20helpful,accidentally%20check%20in%20anything%20sensitive). Samoin voidaan varmuuden vuoksi ignorettaa muutkin mahdolliset polut, joihin dataa voisi ilmestyä (kuten käyttäjän kotihakemistoon osoittavat linkit tms., jos relevanttia).

* **Polkujen hallinta:** Suunnittele koodi niin, että raakadatan polku on konfiguroitavissa. Esimerkiksi käytä ympäristömuuttujaa tai erillistä konfiguraatiotiedostoa, josta haetaan datahakemiston sijainti. Oletuksena koodi voi olettaa, että data löytyy esim. polusta ../data\_secure/ suhteessa projektikansioon, tai että käyttäjä asettaa polun. Dokumentoi tämä selkeästi. Tällä tavalla projekti on siirrettävissä eri ympäristöihin helposti: datan voi sijoittaa haluttuun paikkaan ja vain päivittää konfiguraation. Varmista myös, että koodi antaa **selkeän virheilmoituksen** tai ohjeen, jos dataa ei löydy määätellystä paikasta (esim. “Dataa ei löydy polusta X. Tarkista, että olet asettanut DATA\_PATH-ympäristömuuttujan ja että sinulla on oikeus dataan.”).

* **Manifesti & data dictionary:** Ota käyttöön datamanifesti, joka säilytetään repossa dokumentaationa dataversioista. Manifesti voi olla esim. data/manifest.yml tai .json, josta käy ilmi mitä datasettiä analyysissa käytetään: tiedoston nimi, koko, viimeinen päivityspäivä, tarkistussumma (esim. SHA-256) ja mahdollinen versio- tai lähdetieto. Kun raakadata päivittyy (uusi versio tai korjaus), päivitä manifestiin nämä tiedot. Tämä auttaa varmistamaan, että käyttäjällä on oikea versio datasta ja mahdollistaa myöhemmin audit trailin (manifestin eri versiot git-historiassa kertovat datan muutoksista). Lisäksi laadi **data dictionary** eli kuvaus datasetin sisällöstä (esim. docs/data\_dictionary.md): mitä muuttujia, sarakkeita tai kenttiä data sisältää, millaisessa muodossa, mahdolliset anonymisoinnit tms. Tämä dokumentaatio on korvaamatonta muille kehittäjille (ja agenteille), jotka eivät näe raakadataa – he ymmärtävät datan rakenteen ja merkityksen metatason kautta.

* **Testausten ja workflow’n mukautus:** Säädä CI/CD-putket ja paikalliset testit niin, etteivät ne vaadi oikeaa raakadataa ajettavakseen, tai että ne käsittelevät vain julkista/synteettistä dataa. Esimerkiksi voit luoda pienen **dummy-datasetin** (ei sisällä oikeita henkilötietoja, mutta rakenteeltaan samanlainen) data/sample/\-hakemistoon. Tätä voidaan käyttää automaattisissa testeissä ja Quarto-dokumentin esimerkkiajoissa. Quarto-raportissa voidaan myös esittää aggregoituja tuloksia tai figuureja, jotka on etukäteen generoitu adminin toimesta oikealla datalla ja tallennettu repossa (nämä aggregaatit eivät paljasta yksilötason tietoja). Tärkeää on, että mikään automaatio (CI, agentti) **ei yritä lukea suoraan suojattua raakadataa**, vaan käyttää joko dummy-tietoja tai ohittaa ne osiot. Tarvittaessa lisää ehtoja workflow-skripteihin: esim. “if DATA\_PATH not set, skip heavy data-dependent steps”. Tämä varmistaa, että pipeline toimii erilaisissa ympäristöissä katkeamatta.

* **Agenttirajaukset:** Mikäli käytössä on tekoälyagentteja tai \-chatboteja, jotka lukevat repositoryn sisältöä (esim. RAG-hakuja varten), **rajaa niiden pääsy vain julkiseen sisältöön**. Varmista, että agentti indeksoi esim. vain README, docs/, src/ ja muut sallitut hakemistot. data/\-hakemiston sisällöstä agentille voidaan antaa luettavaksi manifesti ja data dictionary, mutta **ei mitään sellaista, mikä sisältää yksilötason dataa**. Koska raakadataa ei ole repossa, agentin näkökulmasta tämä on yksinkertaista: se käsittelee vain repositorion julkisia tietoja. Dokumentoi myös selvästi, mitä agentti saa tehdä: esim. se voi vastata kysymyksiin datan rakenteesta tai tilastollisista yhteenvedoista, mutta ei koskaan saa päästä käsiksi alkuperäisiin tietueisiin. (Tämä ehto toteutuu teknisesti jo sillä, että data ei ole saatavilla agentin ympäristössä.)

## Vaadittavat muutokset repositorioon

Toteuttaaksemme edellä mainitun mallin, repo tarvitsee seuraavat muutokset:

* **Poista salattu raakadata:** Poista data/external/\-kansiosta nykyinen GPG-salattu tiedosto(t) ja siihen liittyvät avauksen scriptit. Esim. tiedosto data/external/raakadata.gpg voidaan poistaa versionhallinnasta (git rm) – tämä on keskeinen muutos, jolla varmistetaan ettei repossa enää ole suojattua dataa (vain julkinen metadata jää).

* **.gitignore\-päivitys:** Lisää .gitignore\-tiedostoon rivi data/external/\*\* (sekä tarvittaessa muut vastaavat polut), jotta poistettu datatiedosto ei palaa vahingossa. Myös esim. mahdollinen data/raw/ tai muut datapolut voidaan ignorettaa varmuuden vuoksi. Commitoi .gitignore\-muutos.

* **Placeholder-tiedosto:** Lisää data/external/README.md (tai nimeltään esim. PLACEHOLDER.txt), jossa kerrotaan lyhyesti: “Tähän hakemistoon EI tallenneta raakadataa. Raakadata sijaitsee organisaation sisäisessä turvallisessa sijainnissa X. Katso projektin README:stä ohjeet datan saamiseksi.” Tämä tiedosto tulee versionhallintaan, jotta hakemisto näkyy ja tarkoitus on selvä kaikille kloonaaville.

* **Manifesti:** Luo uusi tiedosto data/manifest.yml (tai .json), joka sisältää metatiedot käytetystä datasta. Esimerkki sisällöstä:

* dataset: "Asiakastiedot 2023"  
  source: "Sisäinen tietovarasto ABC, export 1.1.2024"  
  size: "12.3 MB"  
  sha256: "abc123...def"  \# raakadatatiedoston tarkistussumma  
  note: "Henkilötiedot poistettu exportissa syntymäaikaa lukuun ottamatta"

* Commitoi tämä manifesti ja jatkossa päivitä sitä aina kun data vaihtuu (uusi export tms). Voit myös lisätä versionumeroinnin jos mahdollista. Manifesti toimii dokumentaationa ja teknisenä tarkistuskeinona (käyttäjä voi verrata omaa tiedostoaan checksumilla).

* **Data dictionary / dokumentaatio:** Lisää repositorioon esim. docs/data\_dictionary.md joka sisältää kuvauksen datan rakenteesta: selite sarakkeille, tietotyypit, sallitut arvot, mahdolliset anonymisointimenetelmät (esim. “Nimet on korvattu pseudonyymeillä”), ym. Tämä tiedosto auttaa ymmärtämään dataa ilman, että itse dataa tarvitsee avata. Se myös tukee agentin toimintaa – agentti voi tästä tiedosta päätellä, mitä data sisältää.

* **README.md päivitys:** Päivitä projektin pääREADME niin, että siinä on erillinen osio “Raakadatan käyttö”. Kuvaile miksi dataa ei ole repossa (tietosuoja) ja miten valtuutettu kehittäjä saa datan käyttöönsä: esim. “Datan saamiseksi ota yhteys projektiadminiin, joka antaa pääsyn suojattuun data-asemaan” tai “Aja skripti scripts/fetch\_data.sh joka lataa tarvittavan tiedoston, edellyttää VPN-yhteyttä”. Kerro myös miten manifestia käytetään (esim. kehotus tarkistaa checksum yhteneväisyyden varmistamiseksi). Lisäksi mainitse, että koodi on tehty toimimaan, vaikka dataa ei olisikaan: tietyt osiot on mockattu dummy-datalla. Tämä opastaa uusia tulokkaita.

* **Skriptit ja konfiguraatio:** (Jos tarpeen) Lisää scripti tai ohje datan tuomiseksi. Esimerkiksi scripts/fetch\_data.sh voisi sisältää komennot, joilla ADMIN voi tuoda päivitetyn raakadataversion suojatusta paikasta paikallisesti (huomioiden, ettei skripti tulosta mitään arkaluontoista). Tämä skripti ei välttämättä ole versionhallinnassa, ellei se ole geneerinen – ohjeistakin voi riittää. Huolehdi myös, että koodin konfiguraatiossa on kohta datan polulle. Voit luoda esim. .env.template\-tiedoston, johon käyttäjä voi täyttää DATA\_PATH="/polku/tiedostoon.csv" ja joka sitten ladataan ajon alussa. Lisää tämä .env\-tai konfiguraatiotiedosto (jossa on vain placeholder-arvot) repositorioon, mutta laita varsinainen konekohtainen .env **gitignoreen** (jottei kukaan committaa omaa polkuaan vahingossa).

* **CI/CD-muutokset:** Muokkaa mahdollisia GitHub Actions / CI-skriptejä: poista kohdat, joissa yritettiin decryptata dataa (nämä eivät enää ole tarpeen). Sen sijaan lisää tarvittaessa askeleita, joilla dummy-data generoidaan tai joilla Quarto-dokumentaatio ajetaan “safe mode” \-tilassa. Esimerkiksi Quarto-renderille voi antaa parametrit, että käytetään pientä esimerkkiaineistoa. Tai vaihtoehtoisesti CI voi noutaa tallennetun valmiin kuvan/taulukon artifactin sijaan. Tärkeintä on varmistaa, että CI-putki ei odota salaista dataa. Voit myös lisätä CI:hin tarkistuksen, että manifestin checksum vastaa jotain odotusta (mutta ilman että dataa on, tämä on lähinnä muistutus, ei verifiointi).

* **Testien päivitys:** Merkitse testit, jotka riippuvat oikeasta datasta, siten että ne skippaantuvat automaattisesti CI:ssä (esim. tunnistamalla ettei dataa ole saatavilla). Voit käyttää esimerkiksi Pythonissa pytest.mark.skipif \-decoratoria tarkistamaan onko DATA\_PATH asetettu. Kirjoita myös muutama testi varmistamaan, että manifestin tiedot täsmäävät (esim. jos dummy-data on käytössä testissä, sen checksum täsmää manifestissa mainittuun dummyyn – näin testaat, että manifesti on ajan tasalla ainakin julkisen osion osalta).

* **Turvallisuushuomio:** Varmista, että et missään tilanteessa commitoi GitHubiin tai versiohallintaan **salausavaimia, salasanoja tai itse raakadataa**. Tämä koskee myös dokumentaatiota: älä kirjaa README:hen mitään luottamuksellista (esim. ei suoria tiedostopolkuja henkilötietovarastoon, ellei se ole yrityksen sisäinen nimityskäytäntö). Ohjeista käyttäjiä pitämään datan ja avaimet vain omissa ympäristöissään.

Yllä olevilla muutoksilla repo refaktoroidaan siten, että se sisältää vain ei-arkaluontoista tietoa, ja kaikki tarvittava raakadata pysyy hallitusti erillisessä sijainnissa.

## Riskit ja mitigoinnit

* **Reproduktiivisuuden heikkeneminen:** Kun data on repossa vain viitteinä, on riski että joku ajaa analyysikoodin väärällä tai vanhalla dataversiolla huomaamattaan. *Mitigointi:* Manifestikäytäntö ja tarkistussummat auttavat – skripti voi esimerkiksi lukea manifestista odotetun checksumin ja varoittaa, jos käyttäjän tuoma tiedosto ei täsmää. Dokumentoi selkeästi, mikä dataversio kuuluu mihinkin koodiversioon. Voidaan myös sopia, että data-asemalla vanhat versiot säilytetään erillisissä hakemistoissa, ja niiden tunnisteet vastaavat manifestin versiota.

* **Inhimilliset virheet datan käsittelyssä:** Ihmiset voivat unohtaa päivittää manifestin tai vahingossa yrittää ladata dataa julkisesta repossa väärään paikkaan. *Mitigointi:* Ota käyttöön **koodikäytännöt**: esim. määritä data loading \-funktio, joka tulostaa selkeän virheen jos manifesti ja data eivät vastaa toisiaan, tai jos dataa ei löydy. Myös code review \-prosessi: valvo, että jokaisessa datapäivitykseen liittyvässä commitissa manifesti päivitetään. Voit jopa tehdä pienen **pre-commit hookin**, joka estää commitoimasta, jos data/manifest.yml on muuttumatta mutta jokin muuhun dataan viittaava osa koodista muuttui merkittävästi.

* **Datan vuotaminen vahingossa kehittäjän toimesta:** Vaikka repo on suojattu, joku tiimissä voisi erehdyksessä jakaa raakadataa väärin (esim. liittää pienen otteen bugiraporttiin tms.). *Mitigointi:* Kouluta tiimiä tietosuojakäytännöistä. Korosta README:ssä ja tiimin viestinnässä, että **raakadataa ei saa liittää mihinkään julkiseen kanavaan** eikä commitoida. Ylläpidä .gitignore-listaa niin, että yleiset tiedostonimet (vaikka data.csv, henkilot.xlsx tms.) on ignorettu. Voit myös hyödyntää työkaluja kuten **git-secrets** tms. skannaamaan commit-ehdotuksia tunnistaen, onko niissä kenties henkilötietoja tai muita tunnettuja kaavoja.

* **Varastoidun datan turvallisuus (repo ulkopuolella):** Mallimme siirtää huomion siihen, että data on toisaalla – esim. verkkolevyllä tai tietokannassa. On riski, jos tuota paikkaa ei ole suojattu riittävästi (pääsy hallitsematon, puuttuu salaus levyllä, varmuuskopiot laiminlyöty). *Mitigointi:* Varmista, että organisaation tietoturva kattaa myös nämä säilytyspaikat: käyttöoikeudet vain niille, jotka datan saavat nähdä, tiedostojen salaus levyllä (rest encryption) jos mahdollista, sekä lokitus siitä kuka dataa lukee. Lisäksi sovella **“privacy by design”** – harkitse, voitaisiinko analyysit tehdä johdetuilla tunnisteilla tai anonymisoidulla datalla alusta asti. Jos raakadata on erittäin kriittistä, voi olla syytä käsitellä se esimerkiksi erillisessä ympäristössä ja tallentaa analyysiin vain aggregaatti- tai pseudonymisoitu data.

* **Ci/CD-agentin mahdollinen väärinkäyttö:** Vaikka CI/agentti ei pääse dataan, joku voisi teoriassa yrittää muokata pipelinea hakemaan dataa luvatta (esim. injektoimalla haitallista koodia, joka pyrkii printtaamaan ympäristömuuttujia tms.). *Mitigointi:* Rajoita CI-putken oikeuksia – älä anna pipelineille mitään credentiaaleja data-alueille. Käytä tarvittaessa erillistä hyväksyntää, jos pipelinea muutetaan (review vaatii, ettei esim. agentille anneta uusia oikeuksia). Agenttien osalta, pidä ne sandboxattuna: agentti saa lukea vain halutut tiedostot, eikä sillä ole suorittavaa pääsyä järjestelmiin joista se voisi vetää raakadataa. Lisäksi, koska repossa ei ole salausavaimia, agentti ei voi vahingossakaan päästä niihin käsiksi.

* **Vaihtoehto A:n harkinta (avainten käyttö automaatiossa):** Huomioidaan lopuksi miksi emme valinneet A:ta: **Turvallista tapaa ajaa workflow’ta salatun datan kanssa CI:ssä ei käytännössä ole**, ilman että avain altistettaisiin jossain muodossa. Avain voisi periaatteessa olla CI-ympäristön salaisuutena, mutta tällöin luotamme täysin CI-palveluun ja skripteihin, ettei avain vuoda – pienikin väärin menevä logitus tai kolmannen osapuolen kirjaston teko voi vuotaa avaimen. Lisäksi agentille avaimen antaminen olisi vielä isompi riski. Ainoa keino käyttää salausta suhteellisen turvallisesti olisi rajata datan dekryptaus vain adminin paikallisiin ajoihin (ei koskaan CI:hin), mikä vesittää automaation idean. Siksi katsomme suoraan, että jos data on niin arkaluontoista, ettei sitä voi tuoda CI:hin, **sitä ei pidä pitää repossakaan** edes salattuna pidemmän päälle. Tämä perusteluna valinnallemme: Option B poistaa tarpeen edes pohtia avainvuotoja CI:ssä, koska mitään avainta tai dataa ei käsitellä automaattiputkissa.

Yhteenvetona, Option B (tai mahdollinen hybridimalli jossa hyödynnetään Option B:n periaatteita yhdistettynä vahvaan dokumentaatioon) tarjoaa parhaan yhdistelmän tietoturvaa ja käytettävyyttä. Sillä varmistetaan, että projekti täyttää tietosuoja- ja compliance-vaatimukset, kuitenkaan estämättä kehitystyön sujuvuutta tai tulevia laajennuksia. Kaikki kriittiset riskit voidaan hallita selkeillä prosesseilla ja teknisillä rajoituksilla, kuten yllä on kuvattu. Tämä antaa tiimille ja sidosryhmille varmuuden siitä, että dataa käsitellään vastuullisesti ja projektin workflow’t pysyvät terveellä pohjalla jatkossakin. [\[8\]](https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control#:~:text=We%20originally%20used%20svn%20externals,just%20simlink%20to%20another%20location)[\[9\]](https://dataengineeracademy.com/blog/data-version-control-a-comprehensive-guide/#:~:text=Challenge%3A%20In%20an%20era%20of,or%20leaks%20of%20confidential%20data)

---

[\[1\]](https://www.fortinet.com/resources/cyberglossary/gdpr#:~:text=information%20to%20the%20data%20collector,is%20accountable%20and%20responsible%20for) What is GDPR? Key Compliance Requirements | Fortinet

[https://www.fortinet.com/resources/cyberglossary/gdpr](https://www.fortinet.com/resources/cyberglossary/gdpr)

[\[2\]](https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control#:~:text=You%27re%20best%20bet%20is%20to,is%20looking%20over%20your%20shoulder) [\[3\]](https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control#:~:text=I%20also%20find%20it%20helpful,accidentally%20check%20in%20anything%20sensitive) [\[8\]](https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control#:~:text=We%20originally%20used%20svn%20externals,just%20simlink%20to%20another%20location) svn \- Where to manage the most sensitive content you have under version control? \- Stack Overflow

[https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control](https://stackoverflow.com/questions/962354/where-to-manage-the-most-sensitive-content-you-have-under-version-control)

[\[4\]](https://news.ycombinator.com/item?id=7508734#:~:text=After%204%20months%20of%20usage%2C,crypt) [\[5\]](https://news.ycombinator.com/item?id=7508734#:~:text=The%20second%20issue%20is%20that,crypt%20versions) [\[7\]](https://news.ycombinator.com/item?id=7508734#:~:text=As%20for%20security%2C%20,your%20suggestion%20of%20a%20command) Storing sensitive data in a git repository using git-crypt | Hacker News

[https://news.ycombinator.com/item?id=7508734](https://news.ycombinator.com/item?id=7508734)

[\[6\]](https://dataengineeracademy.com/blog/data-version-control-a-comprehensive-guide/#:~:text=Solution%3A%20One%20of%20DVC%E2%80%99s%20strengths,storage%20utilization%20and%20rapid%20synchronization) [\[9\]](https://dataengineeracademy.com/blog/data-version-control-a-comprehensive-guide/#:~:text=Challenge%3A%20In%20an%20era%20of,or%20leaks%20of%20confidential%20data) Data Version Control: A Comprehensive Guide

[https://dataengineeracademy.com/blog/data-version-control-a-comprehensive-guide/](https://dataengineeracademy.com/blog/data-version-control-a-comprehensive-guide/)